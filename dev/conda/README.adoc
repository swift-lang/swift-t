
= Swift/T Anaconda Packages

:toc:

== Quickstart

* Use `./conda-build.sh` to build the Conda package.
** This always does `conda build purge-all`, which is necessary
* Use `conda-install.sh` to install the Conda package
** This installs the deps separately

== Package list

We are Anaconda project `swift-t`: +
https://anaconda.org/swift-t

`swift-t`:: Swift/T with Python 3.9
`swift-t-r`:: Swift/T with Python 3.9 and R

== End user interface

The users should be able to simply do:

----
$ conda install -c conda-forge mamba
$ mamba install -c conda-forge -c swift-t swift-t
# or
$ mamba install -c conda-forge -c swift-t swift-t-r
----

== Supported platforms

These are standard directory names:

* `linux-64`:  "Linux on PC":  Works
* `osx-64`:    "Mac on PC":    WIP
* `aarch64`:   "Linux on ARM": TODO
* `osx-arm64`: "Mac on ARM":   ?

== Definitions

PKG::
The package generated by `conda build`

CONDA::
The maintainer's Conda installation/environment used to build the PKG

RECIPE_DIR::
One such directory per platform, e.g., `/path/to/swift-t/dev/conda/linux-64` +
This is set in the environment at build time by Conda.

LOG::
The output from `build-generic.sh`.  Should be in `RECIPE_DIR`.

== Script architecture

. Each `RECIPE_DIR` directory has a `build-platform.sh` script to start the build.
. This calls the top-level `conda-build.sh` script.
. This sets up `meta.yaml` for the `RECIPE_DIR`
. `conda build` calls `build.sh` for the `RECIPE_DIR`, but this simply
  calls the reusable `build-generic.sh` at the top level.

== Maintainer workflow

Setup:

* Run `setup-conda.sh` to setup a working Conda environment
* Run the Swift/T `dev/release/make-release-pkg.sh` script to
  create the "exported" Swift/T source tree in `/tmp`.
  This source code location is hard-coded into `meta.yaml`.

Loop:

* Run `build-platform.sh`.  See notes there.
* Check `conda-build.log` (`LOG`) for errors.
* Add debug output to `build.sh` as needed to diagnose problems.
* Run `conda-install.sh` to test the installation.  See notes there.

== To create a new platform

* Copy the platform-specific directory
* Run the `build-platform.sh` script and debug it

== Anaconda tips

=== Input files

* `meta.yaml`
** Used by `conda build` to find metadata and dependencies
* `build.sh`
** Executed by `conda build` to compile C code, etc.

=== `conda build` behavior

We call `conda build` inside our `conda-build.sh`

. `conda build`
.. Conda creates a temporary environment
.. Installs your packages from `meta.yaml` in that environment
.. Copies `build.sh` to that environment as `conda_build.sh'
.. Runs your `build.sh` script in that environment
.. Bundles the environment
.. Leaves it at: `CONDA/conda-bld/linux-64/swift-t-*.tar.bz2`
. `conda install`
.. Unpacks the bundle
.. Performs path string renaming for libraries and scripts
.. Copies everything into the target Conda environment

=== Speed

It is best to create a Miniconda installation in RAM disk on your system
for building the packages.  Installing Miniconda should take less than 10 seconds.

== Upload to Anaconda

The Anaconda package name is taken from `meta.yaml` and put in the PKG.

----
$ P=CONDA/conda-bld/linux-64/swift-t-*.tar.bz2
$ anaconda login
$ anaconda upload $P
----

== M4 usage

We use M4 to preprocess `meta.yaml` and `settings.sed`.

. `meta.yaml` configures the Conda environment,
  so we preprocess this file to:
.. set metadata
.. set environment variables
.. select dependency packages
. `settings.sed` preprocesses `swift-t-settings.sh`
  so we preprocess this file to:
.. enable/disable R

We restrict our M4 usage to:

* `m4_include()`: does simple file insertion
* `m4_ifelse()`: does conditional substitution
* `getenv()`: substitutes in an environment variable value

We pull `common.m4` from Turbine to get `getenv()`.
