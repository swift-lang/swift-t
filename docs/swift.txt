
////
Swift/T guide, asciidoc format
http://www.mcs.anl.gov/exm/local/guides/stc.html
////

:toc:
:numbered:

////
Settings:
////
:miscellaneous.newline: \n

= Swift/T Guide

The Swift/Turbine Compiler (STC) allows you to write Swift programs
and run them using Turbine.

== Installation

Writing and running Swift/Turbine programs requires multiple packages.
These have been packaged for convenient download and installation.

1. Install or locate MPI implementation (MPICH, OpenMPI, etc.)
+
Cf. http://www.mcs.anl.gov/research/projects/mpich2/documentation/index.php?s=docs[MPICH Guides]
+
Ensure that MPI is compiled as a shared library
(for MPICH use +configure --enable-shared+).
Other MPI implementations are <<Build_settings, supported>> as well.
+
2. Install or locate Tcl 8.5
+
Cf. http://www.tcl.tk[Tcl web site]
+
3. Obtain the package
+
----
wget http://www.mcs.anl.gov/exm/local/downloads/exm-0.1.0.tar.gz
----
+
Cf. http://www.mcs.anl.gov/exm/local/downloads/downloads.html[Swift/T Downloads]
for other packages
+
4. Unpack and enter package directory
+
----
tar xfz exm-trunk.tar.gz
cd exm-trunk
----
5. Edit the settings file: +exm-settings.sh+
+
This allows you to change the installation location, etc.
+
TIP: Save your +exm-settings.sh+ when you download a new package
+
6. Run the setup script
+
----
./exm-setup.zsh
----
7. Add Turbine and STC to your paths
----
PATH=${PATH}:/path/to/exm-install/turbine/bin
PATH=${PATH}:/path/to/exm-install/stc/bin
----

Alternatively, each component may be compiled separately.  The
+exm-setup.zsh+ script is relatively simple to read and modify.

If +exm-setup.zsh+ does not succeed on your system, see Section
<<Build_settings, Build settings>> below.

== Usage

Swift code is conventionally written in +\*.swift+ files.  Turbine
code is stored in Tcl files +*.tcl+.  After writing the Swift program
+program.swift+, run:
----
stc program.swift program.tcl
----

Then, to run the program, use Turbine:

----
turbine -n 4 program.tcl
----

See the Turbine section <<Turbine>> for more information about
running the program.

STC accepts the following arguments:

+-E+:: Just run the preprocessor
+-I+:: Add a preprocessor include path
+-O+:: Set optimization level: 0, 1, 2, or 3.  See <<Optimizations>>
+-T+:: Enable optimization
+-t+:: Disable optimization
+-u+:: Only compile if output file is not up-to-date
+-v+:: Output version number and exit

== Program Structure

Swift programs are composed of _composite_ functions.  These
share syntax with C-like languages.  The program starts in +main()+.
The following is a complete Swift program:

----
#include <builtins.swift>
main
{}
----

As shown, STC input is preprocessed by +cpp+, the C preprocessor.
Including +builtins.swift+ is required.

Hello world is thus:

----
#include <builtins.swift>
#include <io.swift>
main
{
  printf("Hello world");
}
----

The newline is supplied by +printf()+.

== Comments

Swift supports C/C++ comments:

----
// This is a comment
/* This is a
comment */
/** Also a
comment */
----

== Dataflow Evaluation

Swift expressions are evaluated in _dataflow_ order:

----
int z1,z2;
int y;
int x = f(y);
y = g(2);
z1 = h(x,y,1);
z2 = h(x,y,2);
int output = r(z1,z2);
----

This allows code to execute as concurrently as possible, limited
only by data availability.  In this example, +g()+ runs first, because it
is dependent only on a literal.  When +y+ is set, +f()+ runs, setting
+x+.  Then, two invocations of +h()+ execute.  Finally, +z1+ and +z2+
are set, allowing +r()+ to run.

Variables may be assigned only once.  Multiple assignment is typically
detected at compile time, although in some cases it will result in a
run time error.  Unassigned variables that are inputs to functions
will lead to a stall in progress.

== Composite functions

Swift code is written in composite functions.

Composite functions have the form:

----
[(<output list>)] function_name [(<input list>)]
{
  statement;
  statement;
  ...
}
----

An empty input or output list may be omitted or written as +()+.

The output list may have more than one entry.  Thus, assignments
may be written as:
----
x1, x2 = f(i1, i2);
// or equivalently:
(x1, x2) = f(i1, i2);
----

== Types
Swift provides a similar range of primitive types to many other
programming languages.  Files are a primitive type in Swift, unlike
in many other languages, and have a number of special characteristics
that merit special mention.
Two basic kinds of data structure are provided: arrays and structs.

=== Primitive Types
Swift has the conventional types:

+string+:: A complete string (not an array of characters).
+int+:: A 64-bit integer.
+float+:: A 64-bit (double-precision) floating point number.
+boolean+:: A boolean (true/false).
+file+:: A file (see Section Files).
+blob+:: External byte data (see Section Blobs).

Literals for these types use conventional syntax:

* +int+ literals are written as decimal numbers, e.g. +-1234+
* +float+ literals are written as decimal numbers with a decimal point,
    e.g +5493.352+ or +1.0+.
    The literals +NaN+ and +inf+ may be used.  In some contexts +int+
    literals are promoted automatically to +float+.
* +boolean+ literals
* +string+ literals are enclosed in double quotes, with a range of escape
    sequences supported:
** \\ for a single backslash
** \" for a quote
** \n for newline
** \t for tab
** \a
** \b
** \f
** \r
** \v
** hexadecimal escape codes, e.g. \xf2


The literals +true+ and +false+ may be used for boolean.

----
int four = 2+2;
string s = "hello ";
string hw = s + "world";
----

=== Files
TODO:

* Basic file type
* Assigning existing file
* Mapping (output mapping)
* Basic functions

=== Blobs
TODO

=== Arrays

Arrays are declared with empty square brackets:

----
int A[];
----

They are dynamically sized.  Arrays are indexed using square brackets.
----
int A[];
int B[];
B = function_returning_array();
A[0] = B[0];
A[1] = B[1];
----

A given array variable must be assigned either _in toto_ (as a whole)
or _in partes_ (piece by piece).  In this example, +B+ is assigned in toto
and +A+ is assigned in partes.  Code that attempts to do both is in error.

Arrays may be used as inputs or outputs of functions.

Arrays are part of Swift dataflow semantics. An array is closed
when all possible insertions to it are complete.
----
(int B[]) f(int j)
{
  int A[];
  A = subroutine_function(1);

  // Error: A has already been assigned in toto:
  A[3] = 4;

  // OK: assigning to output variable
  B = subroutine_function(2);
}

----

Array literals may be expressed using the range operator:
----
int start = 0;
int stop = 10;
int step = 2;
// Array of length 10:
int A[] = [start:stop];
// Array of length 5, containing only even numbers:
int B[] = [start:stop:step];
----

Array literals may also be expressed with list syntax:
----
int C[] = [4,5,6];
----

=== Structs

In Swift, structs are defined with the +type+ keyword.  They define
a new type.

----
type person
{
  string name;
  int age;
  int events[];
}
----

Structs are accessed with the +.+ syntax:

----
person p;
p.name = "Abe";
p.age = 90;
----

== Control structures

Swift provides control structures that may be placed as statements
inside a composite function.

=== Conditionals

==== If statement

If statements have the form:

----
if (<condition>)
{
  statement;
  ...
}
else
{
  statement;
  ...
}
----

As required by dataflow processing, progress blocks on the availability
of the condition value.

==== Switch statement

----
int a = 20;
switch (a)
{
  case 1:
    int c;
    c = a + a;
    b = a + 1;
  case 20:
    b = 1;
  case 2000:
    b = 2;
  default:
    b = 2102 + 2420;
}
printf("b: %i\n", b);
----

=== Iteration

Iteration is performed with the +foreach+ and +for+ statements.

==== Foreach statement

The +foreach+ statement allows for iteration over an array:

----
string A[];
foreach index, value in A
{
  printf("A[%i] = %s\n", index, value);
}
----

The +index+ and +value+ variables are automatically declared.  The
+index+ variable may be omitted from the syntax.

A special case of the foreach loop occurs when combined with the
array range operator.  This is the idiomatic way to iterate over
a range of integer values in Swift. The STC compiler has special
handling for this case that avoids constructing an array.

----
foreach i in [start:stop:step] {
    ...
}
----

==== For statement

The +for+ statement allows for sequential iteration.  This example
implements a counter based on the return values of a function that
accepts integers:

----
int N = 100;
int count = 0;
for (int i = 0; i < N; i = i+1, count = count+c)
{
  int c;
  if (condition_function(i))
  {
    c = 1;
  }
  else
  {
    c = 0;
  }
}
----

The general form is:
----
for ( <initializer> ; <condition> ; <updates> )
{
  statement;
  ...
}
----

The initializer is executed first, once.  The initializer is a
comma-separated list of statements.  The body statements are then
executed.  Then, the assignments are performed, formatted as a
comma-separated list.  Each is a special assignment in which the
left-hand-side is the variable in the _next_ iteration of the loop,
while the right-hand-side is the variable in the _previous_ loop
iteration.  Then, the condition is checked for loop exit.  If the loop
continues, the body is executed again, etc.

=== Scoping blocks

Arbitrary scoping blocks may be used.  In this example, two different
variables, both represented by +b+, are assigned different values.

----
{
  int b;
  b = 1;
}
{
  int b;
  b = 2;
}
----

== Operators

The following binary arithmetic operators on numbers are defined:

+&#43;+ (plus), +-+ (minus), +\*+ (times), +/+ (divide),
+%/+ (integer divide), +**+ (power)

+&&+ (boolean and), +||+ (boolean or),
+==+ (equals), +!=+ (not equals), +>+ (greater than), +<+ (less than),
+>=+ (greater than or equal to), +<=+ (less than or equal to)

The following unary operators are defined:

+-+ (negate), +!+ (boolean not)

String concatenation is also performed with +&#43;+ (plus).
+==+ and +!=+ may also be used on strings.

== Standard Library

Each category of function is shown with the required include
statement, if necessary.

Functions that accept an input of any type are denoted +anything+.
Functions that accept variable numbers of arguments are denoted with
ellipsis +...+.

A function that accepts more than one type is denoted as +f(int|string)+.

=== Type conversion

+fromint(int)     -> string+:: Convert integer to string
+toint(string)    -> int+::    Convert string to integer
+fromfloat(float) -> string+:: Convert float to string
+tofloat(string)  -> float+::  Convert string to float
+itof(int)        -> float+::  Convert integer to float

=== Output

+trace(anything, anything, ...)+:: Report the value of any variable

 #include <io.swift>

+printf(string format, int|float|string|boolean...)+::
As +printf()+ in C

=== String functions

+strcat(string,string)+: Concatenation

 #include <string.swift>

+substring(string s, int start, int length) -> string+::
Obtain substring of given string +s+ starting at character +start+ and of
length +length+

+split(string s, string delimiter) -> string[]+::
Tokenize string +s+ with given delimiter

 #include <io.swift>

+sprintf(string format, int|float|string|boolean...)+::
As +sprintf()+ in C

=== Math

 #include <math.swift>

+floor(float i) -> int+:: Round down
+ceil(float i) -> int+:: Round up
+round(float i) -> int+:: Round nearest
+log(float i) -> float+:: Natural logarithm
+exp(float i) -> float+:: Natural exponentiation: e^i^
+sqrt(float i) -> float+:: Square root
+is_nan(float i) -> boolean+:: Check for NaN
+abs_integer(int) -> int+:: Absolute value
+abs_float(float) -> float+:: Absolute value

 #include <random.swift>

+random() -> float+:: Obtain random number
+randint(int start, int end)+::
Obtain random integer from +start+, inclusive, to +end+, exclusive

 #include <stats.swift>

+sum_integer(int[]) -> int+:: Sum
+avg(int|float[]) -> float+:: Average

=== System

 #include <sys.swift>

+getenv(string) -> string+:: Obtain an environment variable

[[argv]]
==== Command line

Consider this command line:

 turbine -l -n 3 program.tcl -v -a=file1.txt file2.txt --exec="prog thing1 thing2" --help file4.txt

The arguments to +program.tcl+ are just the tokens after +program.tcl+

+args() -> string+::
Obtain all arguments as single string
E.g., +"-v -a=file1.txt file2.txt --exec="prog thing1 thing2" --help file4.txt"+

The remaining functions are convenience functions oriented around
Swift conventions.  Under these conventions, the example command above
has _flagged_ arguments +v+, +a=file.txt+, +exec="prog thing1
thing2"+, and +help+. The command has _unflagged_ arguments
+file2.txt+ and +file4.txt+

+argc()+::
Get count of unflagged arguments

+argv(string|int)+::
Given a string, returns the flagged argument with that key:
+
 argv("a") -> file1.txt
+
Given an integer, returns the unflagged argument at that index:
+
 argv(2) → file4.txt
+
Given 0, returns the program name,
+
 argv(0) → /path/to/program.tcl

+argv_accept(string...)+::
If program is given command line arguments not contained in given list, abort
E.g., +argv_accept("x")+ would cause program failure at run time

+argv_contains(string) -> boolean+::

Test if the command line contains the given flagged argument:

 argv_contains("v") -> true

==== Debugging

 #include <assert.swift>

+assert(boolean condition, string message)+::
If condition is false, report +message+ and exit immediately.

[[Turbine_information]]
==== Turbine information

+adlb_servers()    -> int+:: Number of ADLB servers
+turbine_engines() -> int+:: Number of Turbine engines
+turbine_workers() -> int+:: Number of Turbine workers

=== Files

TODO: filename, etc

== Defining Leaf functions

In typical Swift applications, the computationally intensive parts of the
application are not written in the Swift language.  Rather,
the work is done by _leaf functions_ that are _composed_ together with
Swift code.  Leaf functions may be extension or app functions.
The builtin functions mentioned above are implemented as extension
functions in Tcl.

=== Swift extension functions

Currently we support Tcl extension functions, where a function is implemented
as a Tcl function.  Tcl has good support for wrapping native C/C\++ functions,
so this provides an indirect way to call C/C++ functions from Swift.

Several components are required to implement a Tcl extension:

-  A Tcl function that supports Swift/T argument passing conventions
-  The requisite files required to build a Tcl package (e.g pkgIndex.tcl)
-  Swift declarations for the function that specify the type of the function
    and the package/function name of the Tcl function

=== App functions

[[Optimizations]]
== Optimizations

The following optimizations are available in STC

[[Turbine]]
== Running in Turbine

The following describes how to run Turbine programs.

=== Architecture

Turbine runs as an MPI program consisting of many processes.  Turbine
programs are ADLB programs.  Thus, they produce and execute discrete
tasks that are distributed and load balanced at run time.

Each process runs in a _mode_: _engine_, _worker_, or _server_.

Engines:: Evaluate the Swift logic.  Produces tasks
Workers:: Performs tasks
Servers:: Distributes tasks

Typical Swift programs perform compute-intensive work in extension
functions.  These always execute on workers.

Engines split up the control logic work among themselves.  This
results in the generation of calls to extension functions.

Servers distribute tasks in a scalable, load balanced manner.  They
also store Swift data (integers, strings, etc.).

=== Invocation

The general form of a Turbine invocation for STC-generated
+program.tcl+ is:

----
turbine <turbine arguments> <program.tcl> <program arguments>
----

The program arguments are available to Swift (<<argv>>).

Turbine accepts the following arguments:

+-l+:: Enable +mpiexec -l+ ranked output formatting
+-n+:: The total number of Turbine MPI processes

The user controls the Turbine run time configuration through
environment variables:

+TURBINE_ENGINES+:: Number of Turbine engines

+ADLB_SERVERS+:: Number of ADLB servers

The remaining processes are workers.  These values are available to
Swift (<<Turbine_information, Turbine information>>).

+TURBINE_LOG=0+:: Disable logging

+ADLB_EXHAUST_TIME+:: Time in seconds taken by ADLB task servers to
shut down. Typically 1.  In very large runs, this may be set to 5 to
ensure correctness.


+TURBINE_LAUNCH_OPTS+::
Provide other arguments to +mpiexec+, such as a machine file, etc.

=== Configuration

The following describes how to turn Swift/T programs in Turbine
on more complex systems.

[[Build_settings]]
==== Build settings

If +exm-setup.zsh+ does not succeed, you may need to change how it
tries to configure and compile Swift/T.

Swift/T is built with standard Ant (Java) and Autotools/Makefile
(C,Tcl) techniques.  The primary control is thus the arguments to
+ant+ or +configure+.

==== Non-standard MPI locations

Configure Turbine with:

----
 --enable-custom --with-mpi-include=/path/to/mpi.h/include
                 --with-mpi-lib-dir=/path/to/mpi_lib/lib
                 --with-mpi-lib-name=funny.mpi.a
----

=== Performance enhancements

1. Disable logging/debugging via environment
2. Disable logging/debugging at configure/compile time
+
** Configure c-utils with +--disable-log+
+
3. Configure everything with +--enable-fast+. This disables assertions
and other checks

//// Local Variables:
//// mode: doc
//// End:
