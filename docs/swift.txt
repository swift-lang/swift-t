
////
Swift/T guide, asciidoc format
http://www.mcs.anl.gov/exm/local/guides/stc.html
////

:toc:
:numbered:

////
Settings:
////
:miscellaneous.newline: \n

= Swift/T Guide

The Swift/Turbine Compiler (STC) allows you to write Swift programs
and run them using Turbine.

== Support

An overview of Swift/T may be found at the ExM project site:

https://sites.google.com/site/exmcomputing

The Swift/T user discussion mailing list is found here:

http://lists.mcs.anl.gov/mailman/listinfo/exm-user

== Installation

Writing and running Swift/Turbine programs requires multiple packages.
These have been packaged for convenient download and installation.

1. Install or locate MPI implementation (MPICH, OpenMPI, etc.)
+
Cf. http://www.mcs.anl.gov/research/projects/mpich2/documentation/index.php?s=docs[MPICH Guides]
+
Ensure that MPI is compiled as a shared library
(for MPICH use +configure --enable-shared+).
Other MPI implementations are <<Build_settings, supported>> as well.
+
2. Install or locate Tcl 8.5
+
Cf. http://www.tcl.tk[Tcl web site]
+
3. Install or locate SWIG
+
Cf. http://swig.org[SWIG web site]
+
4. Obtain the package
+
----
wget http://www.mcs.anl.gov/exm/local/downloads/exm-0.2.0.tar.gz
----
+
Cf. http://www.mcs.anl.gov/exm/local/downloads/downloads.html[Swift/T Downloads]
for other packages
+
5. Unpack and enter package directory
+
----
tar xfz exm-trunk.tar.gz
cd exm-trunk
----
+
6. Edit the settings file: +exm-settings.sh+
+
This allows you to change the installation location, etc.
+
TIP: Save your +exm-settings.sh+ when you download a new package
+
7. Run the setup script
+
----
./exm-setup.zsh
----
8. Add Turbine and STC to your paths
----
PATH=${PATH}:/path/to/exm-install/turbine/bin
PATH=${PATH}:/path/to/exm-install/stc/bin
----

Alternatively, each component may be compiled separately.  The
+exm-setup.zsh+ script is relatively simple to read and modify.

If +exm-setup.zsh+ does not succeed on your system, see Section
<<Build_settings, Build settings>> below.

== Usage

Swift code is conventionally written in +\*.swift+ files.  Turbine
code is stored in Tcl files +*.tcl+.  After writing the Swift program
+program.swift+, run:
----
stc program.swift program.tcl
----

Then, to run the program, use Turbine:

----
turbine -n 4 program.tcl
----

See the Turbine section <<Turbine>> for more information about
running the program.

STC accepts the following arguments:

+-E+:: Just run the preprocessor
+-I+:: Add a preprocessor include path
+-O+:: Set optimization level: 0, 1, 2, or 3.  See <<Optimizations>>
+-T+:: Enable optimization
+-t+:: Disable optimization
+-u+:: Only compile if output file is not up-to-date
+-v+:: Output version number and exit

== Program Structure

Swift programs are composed of _composite_ functions.  These
share syntax with C-like languages.  The program starts in +main()+.
The following is a complete Swift program:

----
#include <builtins.swift>
main
{}
----

As shown, STC input is preprocessed by +cpp+, the C preprocessor.
Including +builtins.swift+ is required.

Hello world is thus:

----
#include <builtins.swift>
#include <io.swift>
main
{
  printf("Hello world");
}
----

The newline is supplied by +printf()+.

== Comments

Swift supports C/C++ comments:

----
// This is a comment
/* This is a
comment */
/** Also a
comment */
----

== Dataflow Evaluation

Swift expressions are evaluated in _dataflow_ order:

----
int z1,z2;
int y;
int x = f(y);
y = g(2);
z1 = h(x,y,1);
z2 = h(x,y,2);
int output = r(z1,z2);
----

This allows code to execute as concurrently as possible, limited
only by data availability.  In this example, +g()+ runs first, because it
is dependent only on a literal.  When +y+ is set, +f()+ runs, setting
+x+.  Then, two invocations of +h()+ execute.  Finally, +z1+ and +z2+
are set, allowing +r()+ to run.

Variables may be assigned only once.  Multiple assignment is typically
detected at compile time, although in some cases it will result in a
run time error.  Unassigned variables that are inputs to functions
will lead to a stall in progress.

== Composite functions

Swift code is written in composite functions.

Composite functions have the form:

----
[(<output list>)] function_name [(<input list>)]
{
  statement;
  statement;
  ...
}
----

An empty input or output list may be omitted or written as +()+.

The output list may have more than one entry.  Thus, assignments
may be written as:
----
x1, x2 = f(i1, i2);
// or equivalently:
(x1, x2) = f(i1, i2);
----

== Types

Swift provides a similar range of primitive types to many other
programming languages.  Files are a primitive type in Swift, unlike
in many other languages, and have a number of special characteristics
that merit special mention.
Two basic kinds of data structure are provided: arrays and structs.

=== Primitive Types

Swift has the conventional types:

+string+:: A complete string (not an array of characters).
+int+:: A 64-bit integer.
+float+:: A 64-bit (double-precision) floating point number.
+boolean+:: A boolean (true/false).
+file+:: A file (see Section Files).
+blob+:: External byte data (see Section Blobs).

Literals for these types use conventional syntax:

* +int+ literals are written as decimal numbers, e.g. +-1234+
* +float+ literals are written as decimal numbers with a decimal point,
    e.g +5493.352+ or +1.0+.
    The literals +NaN+ and +inf+ may be used.  In some contexts +int+
    literals are promoted automatically to +float+.
* +boolean+ literals
* +string+ literals are enclosed in double quotes, with a range of escape
    sequences supported:
** \\ for a single backslash
** \" for a quote
** \n for newline
** \t for tab
** \a
** \b
** \f
** \r
** \v
** hexadecimal escape codes, e.g. \xf2


The literals +true+ and +false+ may be used for boolean.

----
int four = 2+2;
string s = "hello ";
string hw = s + "world";
----

=== Files

A file is a first-class entity in Swift that in many ways can be treated
as any other variable.  The main difference is that a file can be
*mapped* to path in a filesystem.  Assigning to a mapped file variable
results in a file being created in the file system at the specified path.
File variables can also be initialized with data from a pre-existing
file using the +input_file+ function.  File paths are relative to the
working directory for Turbine.

For example, if +/home/user/in.txt+ is a file with some data in it,
the following Swift program will copy the file to +/home/user/out.txt+.
----
main
{
  file x = input_file("/home/user/in.txt");
  file y <"/home/user/out.txt">; // Declare a mapped file
  y = x; // Do the copy
}
----


A range of functions to work with files are provided in the
+files+ library module.

----
// Initialize an array of files from a range of files on disk with glob
file f[] = glob("directory/*.txt");

// Read the contents of a file with readFile
string filename = "in.txt";
string contents = readFile(input_file(filename));
trace("Contents of " + filename + ":\n" + contents);

// Write directly to a file with writeFile
file tmp = writeFile("first line\nsecond line");

// Find the name of a file with filename
trace("Temporary filename is: " + filename(tmp));
----

Temporary files are created as necessary if unmapped files are
written to.  For example, the file +tmp+ in the above code snippet.

Currently Swift/T assumes that the file system is shared between
all nodes.

=== Blobs
TODO

=== Arrays

Arrays are declared with empty square brackets:

----
int A[];
----

They are dynamically sized, expanding each time an item is inserted at
a new index.  Arrays are indexed using square brackets.
----
int A[];
int B[];
B = function_returning_array();
A[0] = B[0];
A[1] = B[1];
----

Each array index can only be assigned to once.

A given array variable must be assigned either _in toto_ (as a whole)
or _in partes_ (piece by piece).  In this example, +B+ is assigned in toto
and +A+ is assigned in partes.  Code that attempts to do both is in error.

Arrays may be used as inputs or outputs of functions.

Arrays are part of Swift dataflow semantics. An array is closed
when all possible insertions to it are complete.
----
(int B[]) f(int j)
{
  int A[];
  A = subroutine_function(1);

  // Error: A has already been assigned in toto:
  A[3] = 4;

  // OK: assigning to output variable
  B = subroutine_function(2);
}

----

Array literals may be expressed using the range operator:
----
int start = 0;
int stop = 10;
int step = 2;
// Array of length 10:
int A[] = [start:stop];
// Array of length 5, containing only even numbers:
int B[] = [start:stop:step];
----

Array literals may also be expressed with list syntax:
----
int C[] = [4,5,6];
----

=== Structs

In Swift, structs are defined with the +type+ keyword.  They define
a new type.

----
type person
{
  string name;
  int age;
  int events[];
}
----

Structs are accessed with the +.+ syntax:

----
person p;
p.name = "Abe";
p.age = 90;
----

=== Defining new types

*Note:* The features in this section are immature, so you will have
a higher probability of encountering compiler bugs.

Swift has two ways to define new types based on existing types.

The first is +typedef+, which creates a new name for the type.
The new type and the existing type will be completely interchangeable,
since they are simply different names for the same underlying type.
The new type name simply serves to improve readability or documentation.

----
typedef newint int;

main {
  // We can freely convert between int and newint
  newint x = 1;
  int y = x;
  newint z = y;
}
----

The second is with +type+, which creates a new type that is a
specialization of an existing type.  That is, it is a distinct
type that is not interchangeable.  A specialized type can be
converted into the original type, but the reverse transformation is
not possible.  This means that you can write functions that are more
strictly typechecked, for example, only accepted particular types of
file.

----
#include <builtins.swift>

typedef sorted_file file;
app (sorted_file out) sort (file i) {
  "/usr/bin/sort" "-o" out i
}

// uniq utility requires sorted input
app (file o) unique (sorted_file i) {
  "/usr/bin/uniq" i @stdout=o
}

main {
  file unsorted = input_file("input.txt");
  sorted_file sorted <"sorted.txt"> = sort(unsorted);
  file u <"unique.txt"> = unique(sorted);

  // Can convert from sorted_file to file
  file result2 = sort(unsorted);

  // This would cause a type error
  // sorted_file not_sorted = unsorted;
}
----

== Control structures

Swift provides control structures that may be placed as statements
inside a composite function.

=== Conditionals

==== If statement

If statements have the form:

----
if (<condition>)
{
  statement;
  ...
}
else
{
  statement;
  ...
}
----

As required by dataflow processing, progress blocks on the availability
of the condition value.

==== Switch statement

----
int a = 20;
switch (a)
{
  case 1:
    int c;
    c = a + a;
    b = a + 1;
  case 20:
    b = 1;
  case 2000:
    b = 2;
  default:
    b = 2102 + 2420;
}
printf("b: %i\n", b);
----

=== Iteration

Iteration is performed with the +foreach+ and +for+ statements.

==== Foreach loop

The +foreach+ loop allows for parallel iteration over an array:

----
string A[];
foreach value, index in A
{
  printf("A[%i] = %s\n", index, value);
}
----

The +index+ and +value+ variables are automatically declared.  The
+index+ variable may be omitted from the syntax.

A special case of the foreach loop occurs when combined with the
array range operator.  This is the idiomatic way to iterate over
a range of integer values in Swift. The STC compiler has special
handling for this case that avoids constructing an array.

----
foreach i in [start:stop:step] {
    ...
}
----

==== For loop

The +for+ loop allows for sequential iteration.  This example
implements a counter based on the return values of a function that
accepts integers:

----
int N = 100;
int count = 0;
for (int i = 0; i < N; i = i+1, count = count+c)
{
  int c;
  if (condition_function(i))
  {
    c = 1;
  }
  else
  {
    c = 0;
  }
}
----

The general form is:
----
for ( <initializer> ; <condition> ; <updates> )
{
  statement;
  ...
}
----

The initializer is executed first, once.  The initializer is a
comma-separated list of statements.  The body statements are then
executed.  Then, the assignments are performed, formatted as a
comma-separated list.  Each is a special assignment in which the
left-hand-side is the variable in the _next_ iteration of the loop,
while the right-hand-side is the variable in the _previous_ loop
iteration.  Then, the condition is checked for loop exit.  If the loop
continues, the body is executed again, etc.

*Performance Tip:* use the +foreach+ loop instead of +for+ if your
loop iterations are independent and can be executed in parallel.

=== Scoping blocks

Arbitrary scoping blocks may be used.  In this example, two different
variables, both represented by +b+, are assigned different values.

----
{
  int b;
  b = 1;
}
{
  int b;
  b = 2;
}
----

== Operators

The following binary arithmetic operators on numbers are defined:

+&#43;+ (plus), +-+ (minus), +\*+ (times), +/+ (divide),
+%/+ (integer divide), +%%+ (modulus), +**+ (power)

+&&+ (boolean and), +||+ (boolean or),
+==+ (equals), +!=+ (not equals), +>+ (greater than), +<+ (less than),
+>=+ (greater than or equal to), +<=+ (less than or equal to)

The following unary operators are defined:

+-+ (negate), +!+ (boolean not)

String concatenation is also performed with +&#43;+ (plus).
+==+ and +!=+ may also be used on strings.

== Standard Library

Each category of function is shown with the required include
statement, if necessary.

Functions that accept an input of any type are denoted +anything+.
Functions that accept variable numbers of arguments are denoted with
ellipsis +...+.

A function that accepts more than one type is denoted as +f(int|string)+.

=== Type conversion

+fromint(int)     -> string+:: Convert integer to string
+toint(string)    -> int+::    Convert string to integer
+fromfloat(float) -> string+:: Convert float to string
+tofloat(string)  -> float+::  Convert string to float
+itof(int)        -> float+::  Convert integer to float

=== Output

+trace(anything, anything, ...)+:: Report the value of any variable

 #include <io.swift>

+printf(string format, int|float|string|boolean...)+::
As +printf()+ in C

=== String functions

+strcat(string,string)+: Concatenation

 #include <string.swift>

+substring(string s, int start, int length) -> string+::
Obtain substring of given string +s+ starting at character +start+ and of
length +length+

+find(string s, string substring, int start_index, int end_index) -> int+::
Find the index of the first occurence of the string +substring+ within
the string +s+ between the indices +start_index+ and +end_index+. Here
an index of +-1+ passed to +end_index+ results in +end_index+ being
treated as the length of the string +s+. +find+ returns +-1+ in case
there is no occurence of +substring+ in +s+ in the specified range.

+string_count(string s, string substring, int start_index, int end_index) -> int+::
Counts the occurences of the string +substring+ within the string +s+
between the indices +start_index+ and +end_index+. Here an index of
+-1+ passed to +end_index+ results in +end_index+ being treated as the
length of the string +s+

+is_int(string s) -> boolean+::
Returns true if string +s+ is a number, else false.

+replace(string s, string substring, string rep_string, int start_index) -> string+::
Obtain the string created by replacing the first occurence of the
string +substring+ within string +s+, after the index +start_index+,
with the string +rep_string+. In case there is no such occurence of
the string +substring+ in string +s+, the original string +s+ is
returned unmodified.

+replace_all(string s, string substring, string rep_string, int start_index) -> string+::
Obtain the string created by replacing all the occurences of the
string +substring+ within string +s+, after the index +start_index+,
with the string +rep_string+. In case no such occurence of +substring+
exists in +s+, the original string +s+ is returned unmodified.

+split(string s, string delimiter) -> string[]+::
Tokenize string +s+ with given delimiter

+trim(string s) -> string+::
Remove leading and trailing whitespace from +s+

 #include <io.swift>

+sprintf(string format, int|float|string|boolean...)+::
As +sprintf()+ in C

=== Math

 #include <math.swift>

+floor(float i) -> int+:: Round down
+ceil(float i) -> int+:: Round up
+round(float i) -> int+:: Round nearest
+log(float i) -> float+:: Natural logarithm
+exp(float i) -> float+:: Natural exponentiation: e^i^
+sqrt(float i) -> float+:: Square root
+is_nan(float i) -> boolean+:: Check for NaN
+abs_integer(int) -> int+:: Absolute value
+abs_float(float) -> float+:: Absolute value

 #include <random.swift>

+random() -> float+:: Obtain random number

+randint(int start, int end)+::
Obtain random integer from +start+, inclusive, to +end+, exclusive

 #include <stats.swift>

+sum_integer(int[]) -> int+:: Sum
+avg(int|float[]) -> float+:: Average

=== System

 #include <sys.swift>

+getenv(string) -> string+:: Obtain an environment variable

[[argv]]
==== Command line

Consider this command line:

 turbine -l -n 3 program.tcl -v -a=file1.txt file2.txt --exec="prog thing1 thing2" --help file4.txt

The arguments to +program.tcl+ are just the tokens after +program.tcl+

+args() -> string+::

Obtain all arguments as single string
+
E.g., +"-v -a=file1.txt file2.txt --exec="prog thing1 thing2" --help file4.txt"+

The remaining functions are convenience functions oriented around
Swift conventions.  Under these conventions, the example command above
has _flagged_ arguments +v+, +a=file.txt+, +exec="prog thing1
thing2"+, and +help+. The command has _unflagged_ arguments
+file2.txt+ and +file4.txt+

+argc()+::
Get count of unflagged arguments

+argv(string)+::
_(argument-value)_
Given a string, returns the flagged argument with that key:
+
+argv("a") -> file1.txt+

+argp(int)+::
_(argument-positional)_
Given an integer, returns the unflagged argument at that index:
+
+argp(2) -> file4.txt+
+
Given 0, returns the program name,
+
+argp(0) -> /path/to/program.tcl+

+argv_accept(string...)+::

If program is given command line arguments not contained in given list,
abort.
E.g., +argv_accept("x")+ would cause program failure at run time

+argv_contains(string) -> boolean+::

Test if the command line contains the given flagged argument:
+
+argv_contains("v") -> true+

==== Debugging

 #include <assert.swift>

+assert(boolean condition, string message)+::
If condition is false, report +message+ and exit immediately.

[[Turbine_information]]
==== Turbine information

+adlb_servers()    -> int+:: Number of ADLB servers
+turbine_engines() -> int+:: Number of Turbine engines
+turbine_workers() -> int+:: Number of Turbine workers

=== Files

+filename(file) -> string+::   Obtain the name of a file
+input_file(string) -> file+:: Obtain a +file+.  At run time, the
filesystem is checked for the given file name
+readFile(file) -> string+::   Read file as a string
+writeFile(string) -> file+::  Write string to file
+glob(string) -> file[]+:: Perform glob operation, returning files
that match.  Available glob symbols include:
+
* +*+: any character sequence (including the zero-length sequence)
* +?+: any character
* +[chars]+: any of the given characters
* +\x+: character +x+
* +{a,b,c,...}+ any of +a+, +b+, +c+, etc.

== Defining Leaf functions

In typical Swift applications, the computationally intensive parts of the
application are not written in the Swift language.  Rather,
the work is done by _leaf functions_ that are _composed_ together with
Swift code.  Leaf functions may be extension or app functions.
The builtin functions mentioned above are implemented as extension
functions in Tcl.

=== Swift extension functions

Currently we support Tcl extension functions, where a function is implemented
as a Tcl function.  Tcl has good support for wrapping native C/C\++ functions,
so this provides an indirect way to call C/C++ functions from Swift.

Several components are required to implement a Tcl extension:

-  Tcl bindings to your function.
-  For complex types such as structures, arrays and files, you may need
   additional logic to marshal inputs and outputs to/from the global
   data store.
-  The requisite files required to build a Tcl package (e.g pkgIndex.tcl)
-  Swift declarations for the function that specify the type of the function
    and the Tcl implementation.

==== Simple Tcl Function Example
In this first example we will implement a trivial Tcl extension function
that doubles an integer.  Here is the Tcl code that will go in
+myextension.tcl+:

----
namespace eval myextension {
  proc double { x } {
    return [ expr $x * 2 ]
  }
}
----

* TODO: info on how to create Tcl package, e.g. pkgIndex.tcl

Here is the Swift function definition that will go in +myextension.swift+:
----
@pure
(int o) double (int i) "myextension" "0.0.1" [
  "set <<o>> [ myextension::double <<i>> ]"
];
----

The above definition has, from left to right, the output arguments,
the name of the new Swift function, input arguments, the name
of the Tcl package containing the file, and the minimum version
of that package.

We tell the compiler how to call our Tcl function using inline
Tcl code as a template with variable names surrounded by +<< >>+
indicating where variables should be substituted.

We can also tell the Swift compiler a little about the function so
that it can better optimize your programs.
For example, +double+ has no side-effects and produces the same result each
time for the same arguments (i.e. is deterministic), so we can flag
it as a +@pure+ function.

If your function has a long running time and should be dispatched
to a worker process for execution, then you need to label the
function as a leaf function, for example:

----
@dispatch=LEAF
(int o) process (int i) "pkg" "0.0.1" [
  "set <<o>> [ pkg::process <<i>> ]"
];
----

==== Swift/Tcl Data Type Mapping
If you are defining Tcl functions in the way above with inline
Tcl code, Swift types are mapped to Tcl types in the following way:

* int/float/string/bool are converted to the standard
  Tcl representations
* blobs are represented as a Tcl list with first element a pointer
  to the data, and the second element the length of the data

==== Writing Custom Tcl interfaces
For Tcl functions that take complex argument types, such as arrays
or structures, you currently need to write a Tcl wrapper function
that is directly passed references to data in Swift's global data store.
In this case your function must manually retrieve/store data from/to the
global distributed data store.

----
(int o) complex (int arr[]) "pkg" "0.0.1" "complex";
----

* TODO: guide to do this.  Can look in turbine/lib for examples


=== App functions

App functions are functions that are implemented as command-line
programs.  These command-line programs can be brought into a Swift
program as functions with typed inputs and outputs.

An app function definition comprises:

* The standard components of a Swift function declaration: input and
    output arguments and the function name.  Note that the output
    variable types are restricted to individual +file+#s#.
* The command line, which comprises an initial string which is the
    executable to run, and then a series of arguments which are
    the command-line arguments to pass to the program.

App arguments can be:

* Literals such as numbers or strings.
* File variables (passed as file paths).
* Other variables, which are converted to string arguments.
    Arrays (including multi-dimensional arrays) are expanded to
    multiple arguments.
* Arbitrary expressions surrounded by parentheses.

Standard input, output and error can be redirected to files.

Join files together:
----
#include <files.swift>

app (file out) cat (file inputs[]) {
  "/bin/cat" inputs @stdout=out
}

main {
  file joined <"joined.txt"> = cat(glob("*.txt"));
}
----

Sleep an arbitrary amount of time:
----

app (void signal) sleep (int secs) {
  "/bin/sleep" secs
}

main {
  foreach time in [1:5] {
    void signal = sleep(time);
    // Wait on output signal so that trace occurs after sleep
    wait(signal) {
      trace("Slept " + fromint(time));
    }
  }
}
----


[[Optimizations]]
== Optimizations
STC performs a range of compiler optimizations that can significantly
speed up most Swift programs.  The optimization level can be controlled
by the +-O+ command line option.  Almost always the default optimization
level +-O2+ is your best choice.

----
# No optimizations at all (not recommended)
stc -O0 example.swift example.tcl

# Basic optimizations (not recommended)
stc -O1 example.swift example.tcl

# Standard optimizations (recommended)
stc example.swift example.tcl
# OR
stc -O2 example.swift example.tcl

# All optimizations (including ones that sometimes hurt performance)
stc -O3 example.swift example.tcl
----

Individual optimizations can be toggled on using +-T <opt name>+
or off with +-t <opt name>+, but this typically is only useful for
debugging.

[[Turbine]]
== Running in Turbine

The following describes how to run Turbine programs.

=== Architecture

Turbine runs as an MPI program consisting of many processes.  Turbine
programs are ADLB programs.  Thus, they produce and execute discrete
tasks that are distributed and load balanced at run time.

Each process runs in a _mode_: _engine_, _worker_, or _server_.

Engines:: Evaluate the Swift logic.  Produces tasks
Workers:: Performs tasks
Servers:: Distributes tasks

Typical Swift programs perform compute-intensive work in extension
functions.  These always execute on workers.

Engines split up the control logic work among themselves.  This
results in the generation of calls to extension functions.

Servers distribute tasks in a scalable, load balanced manner.  They
also store Swift data (integers, strings, etc.).

=== Concurrency

The available concurrency and efficiency in your Swift script is
limited by the following factors:

* The available concurrency in the Swift logic.  Sequential
  dependencies will be evaluated sequentially.  +foreach+ loops and
  branching function calls may be evaluated concurrently
* The number of workers available to process leaf functions
  concurrently
* The number of engines and servers available to control the Turbine
  run.  Adding more engines and servers usually improves performance
  but costs processes

=== Invocation

The general form of a Turbine invocation for STC-generated
+program.tcl+ is:

----
turbine <turbine arguments> <program.tcl> <program arguments>
----

The program arguments are available to Swift (<<argv>>).

Turbine accepts the following arguments:

+-l+:: Enable +mpiexec -l+ ranked output formatting
+-n+:: The total number of Turbine MPI processes

The user controls the Turbine run time configuration through
environment variables:

+TURBINE_ENGINES+:: Number of Turbine engines

+ADLB_SERVERS+:: Number of ADLB servers

The remaining processes are workers.  These values are available to
Swift (<<Turbine_information, Turbine information>>).

+TURBINE_LOG=0+:: Disable logging

+ADLB_EXHAUST_TIME+::
Time in seconds taken by ADLB task servers to shut down.  May include
a decimal point.  Default +0.1+ .  In very large runs, this may be set to
5 to ensure correctness.

+TURBINE_LAUNCH_OPTS+::
Provide other arguments to +mpiexec+, such as a machine file, etc.

+TURBINE_SRAND+::
If unset or empty, the random number generator seed will be set to the
process rank for each process, giving reproducible results.  If set to
an integer +seed+, the random number generator seed for each process
will be set to +seed+ + +rank+.
+
For non-reproducible random results, use the following shell commands:
+
----
export TURBINE_SRAND=$( date +%s )
turbine ...
----
+
The seed is recorded in the log.

=== Configuration

The following describes how to turn Swift/T programs in Turbine
on more complex systems.

[[Build_settings]]
==== Build settings

If +exm-setup.zsh+ does not succeed, you may need to change how it
tries to configure and compile Swift/T.

Swift/T is built with standard Ant (Java) and Autotools/Makefile
(C,Tcl) techniques.  The primary control is thus the arguments to
+ant+ or +configure+.

==== Non-standard MPI locations

Configure Turbine with:

----
 --enable-custom --with-mpi-include=/path/to/mpi.h/include
                 --with-mpi-lib-dir=/path/to/mpi_lib/lib
                 --with-mpi-lib-name=funny.mpi.a
----

==== Known systems

See the
http://www.mcs.anl.gov/exm/local/guides/turbine-sites.html[Turbine Sites Guide]
for information about specific systems with Turbine installations.

=== Performance enhancements

1. Disable logging/debugging via environment
2. Disable logging/debugging at configure/compile time
+
** Configure c-utils with +--disable-log+
+
3. Configure everything with +--enable-fast+. This disables assertions
   and other checks
4. When making performance measurements, always subtract 1 second
   (or the value of +ADLB_EXHAUST_TIME+) from the Turbine run time
   due to the ADLB shutdown protocol, which does not start until the
   system is idle for that amount of time.

////
Local Variables:
mode: doc
End:
////
