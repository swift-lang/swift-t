
////
Swift/T guide, asciidoc format
http://www.mcs.anl.gov/exm/local/guides/stc.html
////

:toc:
:numbered:

////
Settings:
////
:miscellaneous.newline: \n

= Swift/T Guide
v0.4.0, July 2013

The Swift/Turbine Compiler (STC) allows you to write Swift programs
and run them using Turbine.

== Support

An overview of Swift/T may be found at the ExM project site:

https://sites.google.com/site/exmcomputing

The Swift/T user discussion mailing list is found here:

http://lists.mcs.anl.gov/mailman/listinfo/exm-user

== Installation

Writing and running Swift/Turbine programs requires multiple packages.
These have been packaged for convenient download and installation.

1. Install or locate MPI implementation (MPICH, OpenMPI, etc.)
+
Cf. http://www.mpich.org[MPICH Guides].
Ensure that MPI is compiled as a shared library
(for MPICH use +configure --enable-shared+).
Other MPI implementations are <<Build_settings, supported>> as well.
+
Swift/T attempts to use MPI 3.0 functionality by default.
To disable this, configure ADLB and Turbine with +--enable-mpi-2+.
+
2. Install or locate Tcl 8.5 or 8.6
+
Cf. http://www.tcl.tk[Tcl web site]
+
3. Install or locate SWIG
+
Cf. http://swig.org[SWIG web site]
+
4. Obtain the package
+
----
wget http://www.mcs.anl.gov/exm/local/downloads/exm-0.4.0.tar.gz
----
+
Cf. http://www.mcs.anl.gov/exm/local/downloads/downloads.html[Swift/T Downloads]
for other packages
+
5. Unpack and enter package directory
+
----
tar xfz exm-trunk.tar.gz
cd exm-trunk
----
+
6. Edit the settings file: +exm-settings.sh+
+
This allows you to change the installation location, etc.
+
TIP: Save your +exm-settings.sh+ when you download a new package
+
7. Run the setup script
+
----
./exm-setup.zsh
----
8. Add Turbine and STC to your paths
----
PATH=${PATH}:/path/to/exm-install/turbine/bin
PATH=${PATH}:/path/to/exm-install/stc/bin
----

Alternatively, each component may be compiled separately.  The
+exm-setup.zsh+ script is relatively simple to read and modify.

If +exm-setup.zsh+ does not succeed on your system, see Section
<<Build_settings, Build settings>> below.

== Usage

Swift code is conventionally written in +\*.swift+ files.  Turbine
code is stored in Tcl files +*.tcl+.  After writing the Swift program
+program.swift+, run:
----
stc program.swift
----

This will compile the program to +program.tcl+

Then, to run the program, use Turbine:

----
turbine -n 4 program.tcl
----

See the <<Turbine,Turbine section>> for more information about
running the program.

STC accepts the following arguments:

+-A+:: Set a command-line argument at compile-time
+-D+:: Define C preprocessor macro
+-E+:: Just run the C preprocessor: do not compile the program
+-I+:: Add a directory to the import search path
+-O+:: Set optimization level: 0, 1, 2, or 3.  See <<Optimizations>>
+-p+:: Disable C preprocessor
+-u+:: Only compile if output file is not up-to-date
+-v+:: Output version number and exit
+-V+:: Verbose output

Additional arguments for advanced users/developers:

+-C+:: Specify an output file for STC internal representation
+-l+:: Specify log file for STC debug log
+-L+:: Specify log file for more verbose STC debug log
+-T+:: Enable a specific optimization.  See <<Optimizations>>
+-t+:: Disable a specific compiler optimization.  See <<Optimizations>>

== Program structure

Swift programs are composed of _composite_ functions.  These
share syntax with C-like languages.  The program starts in +main()+.
The following is a complete Swift program:

----
main
{}
----

STC input is preprocessed by +cpp+, the C preprocessor.

Hello world is written as:

----
import io;
main
{
  printf("Hello world");
}
----

The newline is supplied by +printf()+.

Swift programs eventually call _leaf_ functions, which are the primary
way to do work.  From the perspective of the Swift script, they are
atomic operations that wait for input variables and set output
variables.  They may be implemented as native code functions or
external application programs.

== Comments

Swift supports C/C++-style comments:

----
// This is a comment
/* This is a
comment */
/** Also a
comment */
----

Additionally, if the preprocessor is disabled, single-line comments
starting with # are supported:
----
# This will work if source file is not preprocessed
----

== Modules

Swift has a module system that allows you to import function and variable
definitions into your source file.
----
import io;
import mypackage.mymodule;
----

The mechanisms for locating source files is as follows:

* STC searches a list of directories in order to find a Swift source
  file in the correct directory with the correct name.
* The standard library is always first on the search path,
    and the current working directory is last.
* Additional directories can be added with the +-I+ option to STC.
* Swift source files must have a +.swift+ suffix.  E.g. +import io;+
  looks for a file called +io.swift+.
* In the case of a multi-part import name, E.g. +import mypackage.mymodule+,
  then, we look for +mymodule.swift+ in subdirectory +mypackage+.

Currently Swift has no notion of namespaces or selective import, so
including a module will import all function and variable definitions
into your current file.

There are two additional ways to include files.

This syntax is completely equivalent, but is also supported for
compatibility:
----
import mypackage.mymodule;
----

The +#include+ syntax uses a different mechanism to import the file: it
uses the C preprocessor to textually include an entire file into the
current one.  Note that +#include+ will only work if the preprocessor
is enabled on the current file.
In contrast to +import+, +#include+ will run the C preprocessor on
any included modules.  +import+ is recommended over +#include+ unless
the imported module requires preprocessing.
----
#include <mypackage/mymodule.swift>
----

== Dataflow evaluation

Swift expressions are evaluated in _dataflow_ order:

----
int z1,z2;
int y;
int x = f(y);
y = g(2);
z1 = h(x,y,1);
z2 = h(x,y,2);
int output = r(z1,z2);
----

This allows code to execute as concurrently as possible, limited
only by data availability.  In this example, +g()+ runs first, because it
is dependent only on a literal.  When +y+ is set, +f()+ runs, setting
+x+.  Then, two invocations of +h()+ execute.  Finally, +z1+ and +z2+
are set, allowing +r()+ to run.

Variables may be assigned only once.  Multiple assignment is typically
detected at compile time, although in some cases it will result in a
run time error.  Unassigned variables that are inputs to functions
will lead to a stall in progress.

== Composite functions

Swift code is written in composite functions.  The composite function
+main+ is required.

Composite functions have the form:

----
[(<output list>)] function_name [(<input list>)]
{
  statement;
  statement;
  ...
}
----

An empty input or output list may be omitted or written as +()+.

The output list may have more than one entry.  Thus, assignments
may be written as:
----
x1, x2 = f(i1, i2);
// or equivalently:
(x1, x2) = f(i1, i2);
----

== Types

Swift provides a similar range of primitive types to many other
programming languages.  Files are a primitive type in Swift, unlike
in many other languages, and have a number of special characteristics
that merit special mention.
Two basic kinds of data structure are provided: arrays and structs.

=== Primitive types

Swift has the conventional types:

+string+:: A complete string (not an array of characters).
+int+:: A 64-bit integer.
+float+:: A 64-bit (double-precision) floating point number.
+boolean+:: A boolean (true/false).
+file+:: A file (see Section Files).
+blob+:: External byte data (see Section Blobs).

Literals for these types use conventional syntax:

* +int+ literals are written as decimal numbers, e.g. +-1234+
* +float+ literals are written as decimal numbers with a decimal point,
    e.g +5493.352+ or +1.0+.
    Scientific notation may be used,
    as in +2.3e-2+ which is equivalent to +0.023+.
    The literals +NaN+ and +inf+ may be used.  In some contexts +int+
    literals are promoted automatically to +float+.
* +boolean+ literals +true+ and +false+ may be used.
* +string+ literals are enclosed in double quotes, with a range of escape
    sequences supported:
** +\\+ for a single backslash
** +\"+ for a quote
** +\n+ for newline
** +\t+ for tab
** +\a+ (alarm)
** +\b+ (backspace)
** +\f+ (form feed)
** +\r+ (carriage return)
** +\v+ (vertical tab)
** octal escape codes, e.g. +\001+
** hexadecimal escape codes, e.g. +\xf2+
* Multi-line strings may be used in two syntaxes:
** Python-style:
+
----
string s =
"""
line data 1
line data 2
""";
----
+
** Asciidoc-style: like Python-style but use 4 dashes instead of 3 quotes.

For more information: http://en.wikipedia.org/wiki/US-ASCII#ASCII_control_code_chart[ASCII control codes].

=== Files

A file is a first-class entity in Swift that in many ways can be treated
as any other variable.  The main difference is that a file can be
*mapped* to path in a filesystem.  Assigning to a mapped file variable
results in a file being created in the file system at the specified path.
File paths can be arbitrary Swift expressions of type +string+.  Absolute
paths or relative paths are specified, with relative paths interpreted
relative to the path in which turbine was run.
File variables can also be initialized with data from a pre-existing
file using the +input_file+ function.  File paths are relative to the
working directory for Turbine.

For example, if +/home/user/in.txt+ is a file with some data in it,
the following Swift program will copy the file to +/home/user/out.txt+.
----
main
{
  file x = input_file("/home/user/in.txt");
  file y <"/home/user/out.txt">; // Declare a mapped file
  y = x; // Do the copy
}
----


A range of functions to work with files are provided in the
+files+ library module.

----
// Initialize an array of files from a range of files on disk with glob
file f[] = glob("directory/*.txt");

// Read the contents of a file with read
string filename = "in.txt";
string contents = read(input_file(filename));
trace("Contents of " + filename + ":\n" + contents);

// Write directly to a file with write
file tmp = write("first line\nsecond line");

// Find the name of a file with filename
trace("Temporary filename is: " + filename(tmp));
----

Temporary files are created as necessary if unmapped files are
written to.  For example, the file +tmp+ in the above code snippet.

Currently Swift/T assumes that the file system is shared among
all nodes.

=== Blobs

Blobs represent native byte data.  They are primarily used to pass
data to and from native code libraries callable from Swift.  They are
like Swift strings but may contain arbitrary data.

Swift provides multiple builtin functions to create blobs, convert
blobs to and from Swift types, and pass blobs to leaf functions.

=== Arrays

Arrays can be declared with empty square brackets:

----
int A[];
----

Arrays with empty square brackets have integer indices.  It is
also possible to declare integers with other index types, such as
strings:

----
string dict[string];
----

They are dynamically sized, expanding each time an item is inserted at
a new index.  Arrays are indexed using square brackets.
----
int A[string];
int B[];
B = function_returning_array();
A["zero"] = B[0];
A["one"] = B[1];
----

Each array index can only be assigned to once.

A given array variable must be assigned either _in toto_ (as a whole)
or _in partes_ (piece by piece).  In this example, +B+ is assigned in toto
and +A+ is assigned in partes.  Code that attempts to do both is in error.

Arrays may be used as inputs or outputs of functions.

Arrays are part of Swift dataflow semantics. An array is closed
when all possible insertions to it are complete.
----
(int B[]) f(int j)
{
  int A[];
  A = subroutine_function(1);

  // Error: A has already been assigned in toto:
  A[3] = 4;

  // OK: assigning to output variable
  B = subroutine_function(2);
}

----

Array literals may be expressed using the range operator:
----
int start = 0;
int stop = 10;
int step = 2;
// Array of length 10:
int A[] = [start:stop];
// Array of length 5, containing only even numbers:
int B[] = [start:stop:step];
----

Array literals may also be expressed with list syntax:
----
int C[] = [4,5,6];
----

=== Structs

In Swift, structs are defined with the +type+ keyword.  They define
a new type.

----
type person
{
  string name;
  int age;
  int events[];
}
----

Structs are accessed with the +.+ syntax:

----
person p;
p.name = "Abe";
p.age = 90;
----

=== Defining new types

Swift has two ways to define new types based on existing types.

The first is +typedef+, which creates a new name for the type.
The new type and the existing type will be completely interchangeable,
since they are simply different names for the same underlying type.
The new type name simply serves to improve readability or documentation.

----
typedef newint int;

main {
  // We can freely convert between int and newint
  newint x = 1;
  int y = x;
  newint z = y;
}
----

The second is with +type+, which creates a new type that is a
specialization of an existing type.  That is, it is a distinct
type that is not interchangeable.  A specialized type can be
converted into the original type, but the reverse transformation is
not possible.  This means that you can write functions that are more
strictly typechecked, for example, only accepted particular types of
file.

*Note:* This feature is immature, so you will have a higher probability
of encountering compiler bugs or limitations.

----

typedef sorted_file file;
app (sorted_file out) sort (file i) {
  "/usr/bin/sort" "-o" out i
}

// uniq utility requires sorted input
app (file o) unique (sorted_file i) {
  "/usr/bin/uniq" i @stdout=o
}

main {
  file unsorted = input_file("input.txt");
  sorted_file sorted <"sorted.txt"> = sort(unsorted);
  file u <"unique.txt"> = unique(sorted);

  // Can convert from sorted_file to file
  file result2 = sort(unsorted);

  // This would cause a type error
  // sorted_file not_sorted = unsorted;
}
----

=== Global Constants

Swift supports a basic feature for defining globally visible constants.  You
can use the +global const+ statement at the top level of the program.  The
syntax only supports literals of scalar types: e.g. integer literals, floating
point literals and string literals.

----
global const string hello = "Hello World";
global const float pi_approx = 3.142;
global const int ONE = 1;

main () {
  trace(hello, pi_approx, ONE);
}
----

*Note:* better support is planned in future for more flexible support for
global variables and code.

== Control structures

Swift provides control structures that may be placed as statements
inside a composite function.

=== Conditionals

==== If statement

If statements have the form:

----
if (<condition>)
{
  statement;
  ...
}
else
{
  statement;
  ...
}
----

As required by dataflow processing, progress blocks on the availability
of the condition value.

==== Switch statement

----
int a = 20;
switch (a)
{
  case 1:
    int c;
    c = a + a;
    b = a + 1;
  case 20:
    b = 1;
  case 2000:
    b = 2;
  default:
    b = 2102 + 2420;
}
printf("b: %i\n", b);
----

=== Iteration

Iteration is performed with the +foreach+ and +for+ statements.

==== Foreach loop

The +foreach+ loop allows for parallel iteration over an array:

----
string A[];
foreach value, index in A
{
  printf("A[%i] = %s\n", index, value);
}
----

The +index+ and +value+ variables are automatically declared.  The
+index+ variable may be omitted from the syntax.

A special case of the foreach loop occurs when combined with the
array range operator.  This is the idiomatic way to iterate over
a range of integer values in Swift. The STC compiler has special
handling for this case that avoids constructing an array.

----
foreach i in [start:stop:step] {
    ...
}
----

==== For loop

The +for+ loop allows for sequential iteration.  This example
implements a counter based on the return values of a function that
accepts integers:

----
int N = 100;
int count = 0;
for (int i = 0; i < N; i = i+1, count = count+c)
{
  int c;
  if (condition_function(i))
  {
    c = 1;
  }
  else
  {
    c = 0;
  }
}
----

The general form is:
----
for ( <initializer> ; <condition> ; <updates> )
{
  statement;
  ...
}
----

The initializer is executed first, once.  The initializer is a
comma-separated list of statements.  The body statements are then
executed.  Then, the assignments are performed, formatted as a
comma-separated list.  Each is a special assignment in which the
left-hand-side is the variable in the _next_ iteration of the loop,
while the right-hand-side is the variable in the _previous_ loop
iteration.  Then, the condition is checked for loop exit.  If the loop
continues, the body is executed again, etc.

*Performance Tip:* use the +foreach+ loop instead of +for+ if your
loop iterations are independent and can be executed in parallel.

=== Explicit data-dependent execution

In general, execution ordering in Swift/T is implicit and driven by
data dependencies.  In some cases it is useful to add explicit data
dependencies, for example if you want to print a message to indicate
that variable was assigned.  It is possible for the programmer to
express additional execution ordering using two constructs: the +wait+
statement and the +\=>+ chaining operator.

In a wait statement, a block of code is executed after
one or more variables are closed.
----
x = f();
y = g();
wait (x) {
  trace("x is closed!");
}
wait(x, y) {
  trace("x and y are closed!");
}
----

The chaining operator chains statements together so that a
statement only executes after the previous statement's output
value is closed.  This is meant to be
a more concise way to express dependencies than the +wait+ statement.
----
sleep(1) =>
  x = f() =>
  int y = g() =>
  trace("DONE!");
----

In order for this to work we define a notion of the *output values*
of a statement.  In the simple case of a function call +f() \=> ...+,
the output values are the output values of the function.  In the
case of and assignment +x = f() \=> ...+ or a declaration,
+int y = g() \=> ...+, then the next statement is dependent on
the assigned values, or the declared values.  Some functions such
as +sleep+ have +void+ output values so that they can be used
in this fashion.

=== Scoping blocks

Arbitrary scoping blocks may be used.  In this example, two different
variables, both represented by +b+, are assigned different values.

----
{
  int b;
  b = 1;
}
{
  int b;
  b = 2;
}
----

== Operators

The following binary arithmetic operators on numbers are defined:

+&#43;+ (plus), +-+ (minus), +\*+ (times), +/+ (divide),
+%/+ (integer divide), +%%+ (modulus), +**+ (power)

+&&+ (boolean and), +||+ (boolean or),
+==+ (equals), +!=+ (not equals), +>+ (greater than), +<+ (less than),
+>=+ (greater than or equal to), +&lt;=+ (less than or equal to)

The following unary operators are defined:

+-+ (negate), +!+ (boolean not)

String concatenation is also performed with +&#43;+ (plus).  +==+ and
+!=+ may also be used on strings.  Operator +s1/s2+ is equivalent to
+s1&#43;"/"&#43;s2+.

== Standard library

Each category of function is shown with the required import
statement, if necessary.

Functions that accept an input of any type are denoted +anything+.
Functions that accept variable numbers of arguments are denoted with
ellipsis +...+.

A function that accepts more than one type is denoted as +f(int|string)+.

If a function is described below an *Import:* label, be sure to
+import+ that package.

=== Type conversion

+fromint(int)     -> string+:: Convert integer to string
+toint(string)    -> int+::    Convert string to integer
+fromfloat(float) -> string+:: Convert float to string
+tofloat(string)  -> float+::  Convert string to float
+itof(int)        -> float+::  Convert integer to float

=== Output

+trace(anything, anything, ...)+:: Report the value of any variable

 import io;

+printf(string format, int|float|string|boolean...)+::
As +printf()+ in C

=== String functions

+strcat(string,string)+: Concatenation

*Import:* +string+

+substring(string s, int start, int length) -> string+::
Obtain substring of given string +s+ starting at character +start+ and of
length +length+

+find(string s, string substring, int start_index, int end_index) -> int+::
Find the index of the first occurence of the string +substring+ within
the string +s+ between the indices +start_index+ and +end_index+. Here
an index of +-1+ passed to +end_index+ results in +end_index+ being
treated as the length of the string +s+. +find+ returns +-1+ in case
there is no occurence of +substring+ in +s+ in the specified range.

+string_count(string s, string substring, int start_index, int end_index) -> int+::
Counts the occurences of the string +substring+ within the string +s+
between the indices +start_index+ and +end_index+. Here an index of
+-1+ passed to +end_index+ results in +end_index+ being treated as the
length of the string +s+

+is_int(string s) -> boolean+::
Returns true if string +s+ is a number, else false.

+replace(string s, string substring, string rep_string, int start_index) -> string+::
Obtain the string created by replacing the first occurence of the
string +substring+ within string +s+, after the index +start_index+,
with the string +rep_string+. In case there is no such occurence of
the string +substring+ in string +s+, the original string +s+ is
returned unmodified.

+replace_all(string s, string substring, string rep_string, int start_index) -> string+::
Obtain the string created by replacing all the occurences of the
string +substring+ within string +s+, after the index +start_index+,
with the string +rep_string+. In case no such occurence of +substring+
exists in +s+, the original string +s+ is returned unmodified.

+split(string s, string delimiter) -> string[]+::
Tokenize string +s+ with given delimiter

+trim(string s) -> string+::
Remove leading and trailing whitespace from +s+

+strlen(string) -> int+::
Obtain the length of the given string

+hash(string) -> int+::
Hash the string to a 32-bit integer

 import io;

+sprintf(string format, int|float|string|boolean...)+::
As +sprintf()+ in C

=== Math

*Import:* +math+

+floor(float i) -> int+:: Round down
+ceil(float i) -> int+:: Round up
+round(float i) -> int+:: Round nearest
+log(float i) -> float+:: Natural logarithm
+exp(float i) -> float+:: Natural exponentiation: e^i^
+sqrt(float i) -> float+:: Square root
+is_nan(float i) -> boolean+:: Check for NaN
+abs_integer(int) -> int+:: Absolute value
+abs_float(float) -> float+:: Absolute value

*Import:* +random+

+random() -> float+:: Obtain random number

+randint(int start, int end)+::
Obtain random integer from +start+, inclusive, to +end+, exclusive

 import stats;

+sum_integer(int[]) -> int+:: Sum
+avg(int|float[]) -> float+:: Average

=== System

*Import:* +sys+

+getenv(string) -> string+:: Obtain an environment variable

[[argv]]
==== Command line

Consider this command line:

 turbine -l -n 3 program.tcl -v -a=file1.txt file2.txt --exec="prog thing1 thing2" --help file4.txt

The arguments to +program.tcl+ are just the tokens after +program.tcl+

+args() -> string+::

Obtain all arguments as single string
+
E.g., +"-v -a=file1.txt file2.txt --exec="prog thing1 thing2" --help file4.txt"+

The remaining functions are convenience functions oriented around
Swift conventions.  Under these conventions, the example command above
has _flagged_ arguments +v+, +a=file.txt+, +exec="prog thing1
thing2"+, and +help+. The command has _unflagged_ arguments
+file2.txt+ and +file4.txt+

In addition to regular run-time arguments, a special feature called
*compile-time arguments* allows keyword arguments to be provided at
compile time.  This allows a specialized, optimized version of code to be
compiled for a particular set of arguments.  Keyword arguments, accessible
through the +argv+ function, can be specified at compile time with the
+-A name=val+ argument to STC. Note that if the argument is re-specified
at run-time, an error will occur.

+argc()+::
Get count of unflagged arguments

+argv(string)+::
_(argument-value)_
Given a string, returns the flagged argument with that key:
+
+argv("a") -> file1.txt+

+argp(int)+::
_(argument-positional)_
Given an integer, returns the unflagged argument at that index:
+
+argp(2) -> file4.txt+
+
Given 0, returns the program name,
+
+argp(0) -> /path/to/program.tcl+

+argv_accept(string...)+::

If program is given command line arguments not contained in given list,
abort.
E.g., +argv_accept("x")+ would cause program failure at run time

+argv_contains(string) -> boolean+::

Test if the command line contains the given flagged argument:
+
+argv_contains("v") -> true+

==== Debugging

*Import:* +assert+

+assert(boolean condition, string message)+::
If condition is false, report +message+ and exit immediately.

[[Turbine_information]]
==== Turbine information

+adlb_servers()    -> int+:: Number of ADLB servers
+turbine_engines() -> int+:: Number of Turbine engines
+turbine_workers() -> int+:: Number of Turbine workers

=== Files

+filename(file) -> string+::   Obtain the name of a file
+input_file(string) -> file+:: Obtain a +file+.  At run time, the
filesystem is checked for the given file name
+read(file) -> string+::   Read file as a string
+write(string) -> file+::  Write string to file
+glob(string) -> file[]+:: Perform glob operation, returning files
that match.  Available glob symbols include:
+
* +*+: any character sequence (including the zero-length sequence)
* +?+: any character
* +[chars]+: any of the given characters
* +\x+: character +x+
* +{a,b,c,...}+ any of +a+, +b+, +c+, etc.

=== Blobs

*Import:* +blob+

+blob_size(blob) -> int+:: Obtain the size of a blob in bytes.

+blob_null() -> blob+:: Obtain an empty blob of size 0.

+blob_from_string(string) -> blob+:: Convert a string into a blob.

+string_from_blob(blob) -> string+:: Convert a blob into a string.  If
the blob is not NULL-terminated, this function appends the
NULL-terminator.

+blob_from_floats(float[]) -> blob+:: Convert an array of Swift floats
(implemented as doubles) to blob containing the C-formatted array of
doubles .

+blob_from_floats(blob) -> float[]+:: Convert blob containing the
C-formatted array of doubles to an array of Swift floats
(implemented as doubles).

+blob_from_ints(int i[]) -> blob+:: Convert blob containing the
C-formatted array of ints to an array of Swift ints (implemented
as 64-bit integers).

+blob_from_file(file) -> blob+:: Reads whole file, returning it as a
blob.

== Defining leaf functions

In typical Swift applications, the computationally intensive parts of
the application are not written in the Swift language.  Rather, the
work is done by _leaf functions_ that are _composed_ together with
Swift code.  Leaf functions may be extension or app functions.

The Swift runtime, Turbine, is built on Tcl, a language which intends
to makes it easy to call C/C\+\+/Fortran functions.  The builtin
functions mentioned above are implemented as extension functions in
Tcl, which may wrap C/C++/Fortran functions.

=== Swift extension functions

Currently we support Tcl extension functions, where a function is
implemented as a Tcl function.  Tcl has good support for wrapping
native C/C\++ functions, so this provides an indirect way to call
C/C++ functions from Swift.

Several components are required to implement a Swift native code function:

-  Tcl bindings to your function.
-  For complex types such as structures, arrays and files, you may need
   additional logic to marshal inputs and outputs to/from the global
   data store.
-  The requisite files required to build a Tcl package
   (e.g +pkgIndex.tcl+)
-  Swift declarations for the function that specify the type of the
   function and the Tcl implementation.

==== Simple Tcl fragment example

In this example, the Swift program will simply use Tcl to output a
string:

----
() my_output (string s) "turbine" "0.0" [
  "puts <<s>>"
];

main {
  my_output("HELLO");
}
----

+puts+ is the Tcl builtin for screen output, like +puts()+ in C.

The above definition has, from left to right, the output arguments
(none), the name of the new Swift function, input arguments, the name
of the Tcl package containing the file (here, none, so we use
+turbine+), and the minimum version of that package (here, 0.0).

We tell the compiler how to call our Tcl function using inline
Tcl code as a template with variable names surrounded by +<< >>+
indicating where variables should be substituted.

==== Simple Tcl package example

In this first example we will implement a trivial Tcl extension function
that doubles an integer.  Here is the Tcl code that will go in
+myextension.tcl+:

----
namespace eval myextension {
  proc double { x } {
    return [ expr $x * 2 ]
  }
}
----

Here is the Swift function definition that will go in +myextension.swift+:
----
@pure
(int o) double (int i) "myextension" "0.0.1" [
  "set <<o>> [ myextension::double <<i>> ]"
];
----

We can also tell the Swift compiler a little about the function so
that it can better optimize your programs.  For example, +double+ has
no side-effects and produces the same result each time for the same
arguments (i.e. is deterministic), so we can annotate it as a +@pure+
function.

If your function has a long running time and should be dispatched to a
worker process for execution, then you need to label the function as a
leaf function, for example:

----
@dispatch=LEAF
(int o) process (int i) "pkg" "0.0.1" [
  "set <<o>> [ pkg::process <<i>> ]"
];
----

Tcl code is conventionally placed into _packages_.  In this example,
+myextension.tcl+ would be part of the package.

More information about building Tcl packages may be found
http://www.tcl.tk/man/tcl8.5/TclCmd/pkgMkIndex.htm[here].  Ultimately,
you produce a +pkgIndex.tcl+ file that contains necessary information
about the package.

To ensure that Swift can find your package, use
----
stc -r <package directory> ...
----
or set +TURBINE_USER_LIB+ at run time.

==== Swift/Tcl data type mapping

If you are defining Tcl functions in the way above with inline
Tcl code, Swift types are mapped to Tcl types in the following way:

* +int+/+float+/+string+/+bool+ are converted to the standard
  Tcl representations
* blobs are represented as a Tcl list with first element a pointer
  to the data, the second element the length of the data, and if
  the blob was loaded from the ADLB data store, a third element
  which is the ADLB ID of the blob
* files are represented as a list, with the first element the
  file path, and the second element a reference count

==== Calling native libraries from Swift

The first step is to test that you can successfully call your
C/C++/Fortran function from a test Tcl script.  If so, you will then
be able to use the Swift->Tcl techniques to call it from Swift.

A popular tool to automate Tcl->C bindings is
http://www.swig.org[SWIG], which will wrap your C/C++ functions and
help you produce a Tcl package suitable for use by Swift.

To call Fortran functions, first wrap your code with
http://fortwrap.sourceforge.net[FortWrap].  Then, use SWIG to produce
Tcl bindings.

==== Writing custom Tcl interfaces

For Tcl functions that take complex argument types, such as arrays or
structures, you may need to write a Tcl wrapper function that is
directly passed references to data in Swift's global data store.  In
this case your function must manually retrieve/store data from/to the
global distributed data store.  In this case, you do not use the STC
Tcl argument substitution syntax (+<<++i++>>+).

Consider this custom Swift->Tcl binding:
----
(int o) complex_function (int arr[]) "pkg" "0.0.1" "complex";
----

This function jumps into Tcl function +complex+, which must
perform its own data dependency management.

See the link:leaf.html[Swift/T Leaf Function Guide] for more
information about this process.

[[app_functions]]
=== App functions

App functions are functions that are implemented as command-line
programs.  These command-line programs can be brought into a Swift
program as functions with typed inputs and outputs.
An app function definition comprises:

* The standard components of a Swift function declaration: input and
    output arguments and the function name.  Note that the output
    variable types are restricted to individual +file+#s#.
* The command line, which comprises an initial string which is the
    executable to run, and then a series of arguments which are
    the command-line arguments to pass to the program.

App arguments can be:

* Literals such as numbers or strings.
* File variables (passed as file paths).
* Other variables, which are converted to string arguments.
    Arrays (including multi-dimensional arrays) are expanded to
    multiple arguments.
* Arbitrary expressions surrounded by parentheses.

Standard input, output and error can be redirected to files.

Join files together:
----
import files;

app (file out) cat (file inputs[]) {
  "/bin/cat" inputs @stdout=out
}

main {
  file joined <"joined.txt"> = cat(glob("*.txt"));
}
----

Sleep an arbitrary amount of time:
----

app (void signal) sleep (int secs) {
  "/bin/sleep" secs
}

main {
  foreach time in [1:5] {
    void signal = sleep(time);
    // Wait on output signal so that trace occurs after sleep
    wait(signal) {
      trace("Slept " + fromint(time));
    }
  }
}
----

=== External scripting support

==== Calling Python

You can evaluate arbitrary Python code from within Swift/T.  For
example, you can perform processing with a Python library.
Once you have that working, you can use Swift/T to coordinate
concurrent calls to that library.

Consider the following Swift script:

----
import io;
import python;

main {
  i = python("print(\"python works\")\n2+2");
  printf("i: %s", i);
}
----

This simply evaluates the Python code line by line. The last line must
return a Python string to Swift, in this case, the Python string
+&#39;4&#39;+.  The expected output is shown below:

----
python works
i: 4
----

Swift multi-line strings may be used to enter more complex Python code
without the explicit use of +\n+.

Additionally, you can call Python libraries such as
http://www.numpy.org[Numpy] if available on your system.  The
following code adds matrices _I_~3~ + _I_~3~ using Numpy arrays.

----
import io;
import python;
import string;

global const string numpy = "from numpy import *\n\n";

typedef matrix string;

(matrix A) eye(int n)
{
  string command = sprintf("repr(eye(%i))", n);
  string code = numpy+command;
  matrix t = python(code);
  A = replace_all(t, "\n", "", 0);
}

(matrix R) add(matrix A1, matrix A2)
{
  string command = sprintf("repr(%s+%s)", A1, A2);
  string code = numpy+command;
  matrix t = python(code);
  R = replace_all(t, "\n", "", 0);
}

main
{
  matrix A1 = eye(3);
  matrix A2 = eye(3);
  matrix sum = add(A1, A2);
  printf("2*eye(3)=%s", sum);
}
----

An Python script template is created that imports Numpy and performs
some simple calculations.  This code is represented in a Swift string.
The template is filled in by the Swift call to +sprintf()+.  Then, the
code is passed to Python for evaluation.  The output is:

----
2*eye(3)=array([[ 2.,  0.,  0.],
                [ 0.,  2.,  0.],
                [ 0.,  0.,  2.]])
----

NOTE: To use this, Turbine must be configured with +--enable-python+
 before compiling.  This feature is implemented by linking to Python
 as a shared library, enabling better performance than calling the
 +python+ program (which may be done by using a normal Swift
 <<app_functions,app function>>).  Error messages for minor coding
 mistakes may be badly mangled and refer to missing Python symbols-
 refer to the first error in the Python stack trace.



==== Calling R

Consider the following Swift script:
----
import io;
import string;
import R;

global const string template =
"""
  x <- %i
  a <- x+100
  cat("the answer is: ", a, "\\n")
  a
""";

main
{
  code = sprintf(template, 4);
  s = R(code);
  printf("the answer was: %i", s);
}
----

An http://www.r-project.org[R language] script template is placed in a
Swift string.  The template is filled in with the value 4 by the Swift
call to +sprintf()+ (note the +%i+ conversion specifier).  Then, the
code is passed to R for evaluation.  The output is:

----
the answer is:  104
the answer was: 104
----

As coded here, both R and Swift report the value of +a+.

NOTE: To use this, Turbine must be configured with +--enable-R+ before
 compiling.  This feature is implemented by linking to R as a shared
 library, enabling better performance than calling the +R+ program
 (which may be done by using a normal Swift
 <<app_functions,app function>>).

[[Optimizations]]
== Optimizations
STC performs a range of compiler optimizations that can significantly
speed up most Swift programs.  The optimization level can be controlled
by the +-O+ command line option.  Almost always the default optimization
level +-O2+ is your best choice.

----
# No optimizations at all (not recommended)
stc -O0 example.swift example.tcl

# Basic optimizations (not recommended)
stc -O1 example.swift example.tcl

# Standard optimizations (recommended)
stc example.swift example.tcl
# OR
stc -O2 example.swift example.tcl

# All optimizations (including ones that sometimes hurt performance)
stc -O3 example.swift example.tcl
----

Individual optimizations can be toggled on using +-T <opt name>+
or off with +-t <opt name>+, but this typically is only useful for
debugging.  You can find an up-to-date list of optimizations in
the stc command-line help:

----
stc -h
----

[[Turbine]]
== Running in Turbine

The following describes how to run Turbine programs.

=== Architecture

Turbine runs as an MPI program consisting of many processes.  Turbine
programs are ADLB programs.  Thus, they produce and execute discrete
tasks that are distributed and load balanced at run time.

Each process runs in a _mode_: _engine_, _worker_, or _server_.

Engines:: Evaluate the Swift logic.  Produces tasks
Workers:: Performs tasks
Servers:: Distributes tasks

Typical Swift programs perform compute-intensive work in leaf
functions.  These always execute on workers.

Engines split up the control logic work among themselves.  This
results in the generation of calls to extension functions.

Servers distribute tasks in a scalable, load balanced manner.  They
also store Swift data (integers, strings, etc.).

=== Concurrency

The available concurrency and efficiency in your Swift script is
limited by the following factors:

* The available concurrency in the Swift logic.  Sequential
  dependencies will be evaluated sequentially.  +foreach+ loops and
  branching function calls may be evaluated concurrently
* The number of workers available to process leaf functions
  concurrently
* The number of engines and servers available to control the Turbine
  run.  Adding more engines and servers usually improves performance
  but costs processes

=== Invocation

The general form of a Turbine invocation for STC-generated
+program.tcl+ is:

----
turbine <turbine arguments> <program.tcl> <program arguments>
----

The program arguments are available to Swift (<<argv>>).

Turbine accepts the following arguments:

+-f <file>+:: Provide a machine file to +mpiexec+
+-h+:: Print a help message
+-l+:: Enable +mpiexec -l+ ranked output formatting
+-n <procs>+:: The total number of Turbine MPI processes
+-v+:: Report the Turbine version number
+-V+:: Make the Turbine launch script verbose

The user controls the Turbine run time configuration through
environment variables:

+TURBINE_ENGINES+:: Number of Turbine engines

+ADLB_SERVERS+:: Number of ADLB servers

The remaining processes are workers.  These values are available to
Swift (<<Turbine_information, Turbine information>>).

+TURBINE_LOG=0+:: Disable logging

+ADLB_EXHAUST_TIME+::
Time in seconds taken by ADLB task servers to shut down.  May include
a decimal point.  Default +0.1+ .  In very large runs, this may be set to
5 to ensure correctness.

+TURBINE_LAUNCH_OPTS+::
Provide other arguments to +mpiexec+, such as a machine file, etc.

+TURBINE_SRAND+::
If unset or empty, the random number generator seed will be set to the
process rank for each process, giving reproducible results.  If set to
an integer +seed+, the random number generator seed for each process
will be set to +seed+ + +rank+.
+
For non-reproducible random results, use the following shell commands:
+
----
export TURBINE_SRAND=$( date +%s )
turbine ...
----
+
The seed is recorded in the log.

=== Configuration

The following describes how to turn Swift/T programs in Turbine
on more complex systems.

[[Build_settings]]
==== Build settings

If +exm-setup.zsh+ does not succeed, you may need to change how it
tries to configure and compile Swift/T.

Swift/T is built with standard Ant (Java) and Autotools/Makefile
(C,Tcl) techniques.  The primary control is thus the arguments to
+ant+ or +configure+.

==== Manual configuration

You do not need to use +exm-setup.zsh+ to install Swift/T.  To perform
the installation using +configure+/+make+, simply untar the
distribution package and do:

----
cd c-utils
./configure ...
make install

cd ../lb
./configure ...
make install

cd ../turbine
./configure ...
make install

cd ../stc
ant -Ddist.dir=... -Dturbine.home=...
----

* You may use +./configure --help+ and the
  link:turbine-sites.html[Sites Guide] for further options.
* You can use +exm-setup.zsh+ as a guide to this process, as it is a
  simple linear shell script that automates the +configure+/+make+
  process.

==== Non-standard MPI locations

Configure Turbine with:

----
 --enable-custom --with-mpi-include=/path/to/mpi.h/include
                 --with-mpi-lib-dir=/path/to/mpi_lib/lib
                 --with-mpi-lib-name=funny.mpi.a
----

==== Known systems

See the
http://www.mcs.anl.gov/exm/local/guides/turbine-sites.html[Turbine Sites Guide]
for information about specific systems with Turbine installations.

=== Performance enhancements

1. Disable logging/debugging via environment
2. Disable logging/debugging at configure/compile time
+
** Configure c-utils with +--disable-log+
+
3. Configure everything with +--enable-fast+. This disables assertions
   and other checks
4. When making performance measurements, always subtract 1 second
   (or the value of +ADLB_EXHAUST_TIME+) from the Turbine run time
   due to the ADLB shutdown protocol, which does not start until the
   system is idle for that amount of time.

////
Local Variables:
mode: doc
End:
////
